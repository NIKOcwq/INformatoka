#Итак-->
**это матем. функции с комплекными.

можно изначально создать комплексное число complex(real[, imag])
( по ее дейсвительной(real) и мнимой ( imag) части тоесть ) 
complex(1, 2e-5)
(1+0.05j)
-----------
a = -5 + 3j
b = 4 + 2j


print(a + b)

->(-1+5j)
----------
a = 2 + 2j


print(a*2)

->(4+4j)

или 

print(a*(-1.5))


->(-3-3j)
----------
a = 1 + 1j
b = 1 + 4j
 
print(a*b)


->(-3+5j)

----------
a = 3 + 8j


print(a/2)

->(1.5+4j)


a = 1 + 2j
b = 2 + 4j
print('Addition =', a + b)
print('Вычитание =', a - b)
print('Сложение =', a * b)
print('Деление =', a / b)

нахождение определителя 

по факту если представить ее в виде функции, то это вектор между осями real и imaginary
то угол между вектором и действительной оью(real)
будет искаться так аргумент это imaginary/real
 или если добавить библеотку math 

chislo = 1 + 2j

p = math.atan(chislo.imag/chislo.real) **cmath.phase(p)**

b = abs(p)

print('Ответ:', b)

нашли и аргумент и модуль

дальше нашел прикол
0j ** 0j
(1+0j)

тоесть косплексный 0 в степени того же комплексного с 0 даст 1 (0_0)

Если честно , если делать первые 4 - 5 строчки по зачету python все норм, нашел и смог понять до монента n степеней и корня , прошарив пол дюжины сайтов нашел пример и смог разобрать его 

import cmath
def roots(z: complex, n):
    assert isinstance(n, int) and n > 1
    r, phi = cmath.polar(z)
    r **= 1 / n
    for k in range(n):
        yield cmath.rect(r, (phi + 2 * cmath.pi * k) / n) ** также есть штука cmath.sqrt(x) которая возвращает квадртаный корень от в нашем случае x**
z1, z2 = roots(1j, 2)
print(z1, z2)
print(cmath.isclose(z1 * z1, 1j))
print(cmath.isclose(z2 * z2, 1j))


Вроде ничего не забыл .( Изначально создал этот txt для себя потом подумал ай да скину тоже и чуть подоформил)



